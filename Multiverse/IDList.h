#pragma once
#include <initializer_list> // initializer_list
#include <iterator>	// iterator, bidirectional_iterator_tag, reverse_iterator
#include <memory>	// allocator, allocator_traits
#include <type_traits>	// is_integral, remove_const
#include <vector>	// vector

namespace mv
{
	template <typename T, typename S, typename Alloc>
	class IDListIterator;

	/**
		\brief IDLists are containers that maintain the id of elements at all times

		this container is optimised for random access but may perform poorly when iterating over elements
		and reallocating in comparison to std::vector
	*/
	template <typename T, typename S = size_type, typename Alloc = std::allocator<T>>
	class IDList
	{
		using vec_type = std::vector<T, Alloc>;

	public:
		using size_type = S;
		using value_type = typename vec_type::value_type;
		using allocator_type = typename vec_type::allocator_type;
		using reference = typename vec_type::reference;
		using const_reference = typename vec_type::const_reference;
		using pointer = typename vec_type::pointer;
		using const_pointer = typename vec_type::const_pointer;
		using iterator = IDListIterator<value_type, size_type, allocator_type>;
		using const_iterator = IDListIterator<const value_type, size_type, allocator_type>;
		using reverse_iterator = std::reverse_iterator<iterator>;
		using const_reverse_iterator = std::reverse_iterator<const_iterator>;
		using difference_type = typename vec_type::difference_type;

	private:
		friend iterator;
		friend const_iterator;

		/// holds the actual data elements 
		std::vector<value_type, allocator_type> _elements;
		/// keeps track of element positions by id
		std::vector<size_type> _lookup;
		/// holds all freed ids
		std::vector<size_type> _freed;

	public:
		/**
			\brief default constructor
		*/
		IDList() = default;
		/**
			\brief default constructor
		*/
		explicit IDList(const allocator_type& alloc);
		/**
			\brief copy constructor
		*/
		IDList(const IDList<T, S, Alloc>& obj) = default;
		/**
			\brief move constructor
		*/
		IDList(IDList<T, S, Alloc>&& obj) noexcept = default;
		/**
			\brief initializer list constructor
		*/
		IDList(std::initializer_list<value_type> values, const allocator_type& alloc = allocator_type());

		~IDList() = default;

		IDList<T, S, Alloc>& operator=(const IDList<T, S, Alloc>& obj) = default;
		IDList<T, S, Alloc>& operator=(IDList<T, S, Alloc>&& obj) noexcept = default;
		

		iterator begin();
		iterator end();
		const_iterator cbegin() const;
		const_iterator begin() const;
		const_iterator cend() const;
		const_iterator end() const;
		reverse_iterator rbegin();
		reverse_iterator rend();
		const_reverse_iterator crbegin() const;
		const_reverse_iterator rbegin() const;
		const_reverse_iterator crend() const;
		const_reverse_iterator rend() const;

		bool empty() const;
		size_type size() const;
		size_type capacity() const;
		static size_type max_size();

		/**
			\brief check whether an id is reserved
			\returns true if id is reserved, else false
			\param id the id to be checked
			\throws - no throw guarantee
			\complexity constant
		*/
		bool is_reserved(size_type id) const;
		/**
			\brief get the next id to be generated by insert or emplace
			\returns the next id to be generated by insert or emplace
			\complexity constant

			the generated id is invalidated together with iterators
		*/
		size_type next_id() const;

		reference operator[](size_type id);
		const_reference operator[](size_type id) const;
		reference at(size_type id);
		const_reference at(size_type id) const;
		pointer data() noexcept;
		const_pointer data() const noexcept;

		/**
			\brief copy element into the container at new id
			\returns id of the newly added element
			\param element the element to be copied into the container
			\complexity constant amortised time
		*/
		size_type insert(const value_type& element);
		bool insert_at(size_type id, const value_type& element);
		/**
			\brief move element into the container at new id
			\returns id of the newly added element
			\param element the element to be moved into the container
			\complexity constant amortised time
		*/
		size_type insert(value_type&& element);
		bool insert_at(size_type id, value_type&& element);
		/**
			\brief construct new element directly into the container at new id
			\returns id of the newly added element
			\param args the values passed to the constructor
			\complexity constant amortised time
		*/
		template <typename... Args>
		size_type emplace(Args&&... args);
		template <typename... Args>
		bool emplace_at(size_type id, Args&&... args);
		/**
			\brief remove a single element from the container
			\param id the id of the element to be removed
			\throws out of range exception if id is not reserved
			\complexity constant
		*/
		void erase(size_type id);
		/**
			\brief remove all elements from the container
			\complexity at most linear in container size, constant if value_type is trivially destructable, depending on stl implementation
				same as std::vector<value_type>::clear

			removed elements are destroyed and size is set to 0
			the stack holding the freed ids is also cleared
		*/
		void clear();
		/**
			\brief shrink container to minimum required size
			\complexity at most, linear in container size
		*/
		void shrink_to_fit();

	private:
		bool _is_reserved(size_type id) const;

		bool _request(size_type id);
	};


	template <typename T, typename S, typename Alloc = std::allocator<typename std::remove_const<T>::type>>
	class IDListIterator
	{
	public:
		using allocator_type = Alloc;
		using iterator_category = std::bidirectional_iterator_tag;
		using value_type = typename std::remove_const<T>::type;
		using difference_type = typename std::allocator_traits<allocator_type>::difference_type;
		using pointer = typename std::conditional<!std::is_const<T>::value, T*, const T*>::type;
		using reference = typename std::conditional<!std::is_const<T>::value, T&, const T&>::type;
		using idlist_type = IDList<typename std::remove_const<typename IDListIterator<T, S, Alloc>::value_type>::type, S, allocator_type>;
		using iterator = typename idlist_type::iterator;
		using const_iterator = typename idlist_type::const_iterator;


	private:
		friend idlist_type;
		friend iterator;
		friend const_iterator;

		typename IDListIterator<T, S, Alloc>::pointer _ptr;

	public:
		IDListIterator() = default;
	private:
		IDListIterator(typename IDListIterator<T, S, Alloc>::pointer ptr);
	public:
		IDListIterator(const IDListIterator<T, S, Alloc>&) = default;
		template <typename = typename std::enable_if<IDListIterator<T, S, Alloc> == const_iterator>::type>
		IDListIterator(const iterator& obj);

		~IDListIterator() = default;


		bool operator==(const iterator& rhs) const;
		bool operator==(const const_iterator& rhs) const;

		bool operator!=(const iterator& rhs) const;
		bool operator!=(const const_iterator& rhs) const;


		typename IDListIterator<T, S, Alloc>::reference operator*() const;
		typename IDListIterator<T, S, Alloc>::pointer operator->() const;


		IDListIterator<T, S, Alloc>& operator++();
		IDListIterator<T, S, Alloc> operator++(int);

		IDListIterator<T, S, Alloc>& operator--();
		IDListIterator<T, S, Alloc> operator--(int);
	};
}

#include "IDList.inl"
